`new this 具体的一个手机`
`static class 唯一的一个模板3`

一个对象里面如果有多个synchronized方法，某个时刻内，只要一个线程去调用其中一个synchronized
方法了，其他的线程都要等待，换句话说，在某个时刻内，只能有唯一一个线程去访问这些
synchronized方法，锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的
synchronized方法
加个普通方法后发现和同步锁无关，换成两个对象后，不是同一把锁，情况立刻变化
都换成静态同步方法后，情况又变化了。所有的非静态的同步方法用的都是同一把锁----实例对象本身
synchronized实现同步的基础：java中的每一个对象都可以作为锁

# 具体的表现为以下三种形式：
对于普通同步方法，锁的是当前实例对象
对于静态同步方法，锁的是当前的Class对象。
对于同步方法块，锁是synchronized括号里面的配置对象
当一个线程试图访问同步代码块时，他首先必须得到锁，退出或者是抛出异常时必须释放锁，也就是说
如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方
法释放锁后才能获取锁，可以是别的实例对象非非静态同步方法因为跟该实例对象的非静态同步方法用
的是不同的锁，所以必须等待该实例对象已经获取锁的非静态同步方法释放锁就可以获取他们自己的
锁。
所有的静态同步方法用的也是同一把锁----类对象本身
这两把锁的是两个不同的对象，所以静态的同步方法与非静态的同步方法之间是不会有竞争条件的，但
是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不
是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要他们用一个的
是同一个类的实例对象。
